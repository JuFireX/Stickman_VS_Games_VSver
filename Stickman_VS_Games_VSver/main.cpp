#include "engine.h"
#include <conio.h>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <memory>
#include <sstream>
#include <streambuf>
#include <string>
#include <vector>
#include <Windows.h>

using namespace std;

static int x = 10, y = 300;
static int BASIC_X = 10, BASIC_Y = 360, BASIC_H=20;

// ???GBK????????????
wstring gbk_to_wstring(const string &str)
{
	int len = MultiByteToWideChar(936, 0, str.c_str(), -1, NULL, 0); // 936=GBK
	wstring wstr(len, L'\0');
	MultiByteToWideChar(936, 0, str.c_str(), -1, &wstr[0], len);
	// ????¦Â??\0
	if (!wstr.empty() && wstr.back() == L'\0')
		wstr.pop_back();
	return wstr;
}

// ???? cls
void clean()
{
	//Sleep(2000);
	cleardevice();
	y = BASIC_Y;
}

// ?????????? pause
void pause(int timeout)
{
	flushmessage(-1);
	if (timeout == -1)
	{
		y += BASIC_H;
		if (y >= 460)
		{
			y = BASIC_Y;
			cleardevice();
		}
		outtextxy(10, y, _T(">>>"));
		y += BASIC_H;

		FlushBatchDraw();
		ExMessage getmessage(BYTE filter = EX_KEY);
		getmessage();
	}
	else
	{
		Sleep(timeout * 1000); // ?????????????????,?????????
	}
}

// ?????????
void streamOutput(const string text, int speed, int timeout, int color = 0xffffff)
{
	LOGFONT f;
	gettextstyle(&f);
	f.lfHeight = 20;
	f.lfWeight = FW_BOLD;
	f.lfOutPrecision = OUT_TT_PRECIS;
	wcscpy_s(f.lfFaceName, _T("Arial"));
	settextstyle(&f);
	setbkmode(TRANSPARENT);
	settextcolor(color);

	// ???
	wstring wtext = gbk_to_wstring(text);
	wstring out;

	if (y >= 460)
	{
		y = BASIC_Y;
		cleardevice();
	}
	ExMessage msg;
	for (wchar_t wc : wtext)
	{
		int a = speed;
		out += wc;
		outtextxy(x, y, out.c_str());
		FlushBatchDraw();
		while (peekmessage(&msg))
		{
			if (msg.message == WM_KEYDOWN)
			{
				if (msg.vkcode == 'Y')
				{
					a = 0;
					break;
				}
			}
		}
		flushmessage();
		Sleep(a);
	}

	y += BASIC_H;
	pause(timeout);
}

// ???????
void directOutput(const string text, int timeout, int color = 0xffffff)
{
	LOGFONT f;
	gettextstyle(&f);
	f.lfHeight = 20;
	f.lfWeight = FW_BOLD;
	f.lfOutPrecision = OUT_TT_PRECIS;
	wcscpy_s(f.lfFaceName, _T("Arial"));
	settextstyle(&f);
	setbkmode(TRANSPARENT);
	settextcolor(color);

	// ???
	wstring wtext = gbk_to_wstring(text);

	if (y >= 460)
	{
		y = BASIC_Y;
		cleardevice();
	}

	outtextxy(x, y, wtext.c_str());
	FlushBatchDraw();

	y += BASIC_H;
	pause(timeout);
}

void clearRect(int top, COLORREF color)
{
	Sleep(2000);
	setfillcolor(color);
	solidrectangle(720, top, 0, 480);
	y = BASIC_Y;
}
// ??????
int choiceOutput(const string &output, const vector<string> &choices, int basec = WHITE, int selectc = RED)
{
	int select = 0;
	int n = (int)choices.size();
	int base_x = 480, base_y = BASIC_Y - (n+1)*BASIC_H, line_h = BASIC_H;
	streamOutput(output, 10, 0, basec);

	while (true)
	{
		for (int i = 1; i <= n; ++i)
		{
			wstring wstr = gbk_to_wstring(to_string(i) + " -> " + choices[i - 1]);
			int y_chioce = base_y + i * line_h;
			if (i == select + 1)
			{
				settextcolor(selectc);
				outtextxy(base_x, y_chioce, wstr.c_str());
			}
			else
			{
				settextcolor(basec);
				outtextxy(base_x, y_chioce, wstr.c_str());
			}
		}
		FlushBatchDraw();

		ExMessage msg;
		while (peekmessage(&msg))
		{
			if (msg.message == WM_KEYDOWN)
			{
				if (msg.vkcode == VK_DOWN || msg.vkcode == 'S')
				{
					select = ((select + 1) % n);
					continue;
				}
				else if (msg.vkcode == VK_UP || msg.vkcode == 'W')
				{
					select = ((select + n - 1) % n);
					continue;
				}
				else if (msg.vkcode == VK_RETURN || msg.vkcode == 'F')
				{
					return select + 1;
				}
				else if ((msg.vkcode - '0') >= 1 && (msg.vkcode - '0') <= n)
				{
					select = (msg.vkcode - '0');
					return select + 1;
				}
				else
				{
					continue;
				}
			}
		}
		Sleep(10);
	}
}
void putImg(int x, int y,int width,int height,string path,int timeout)
{
	IMAGE temp;
	Engine* engine1 = new Engine();
	std::wstring wpath = std::wstring(path.begin(), path.end());
	loadimage(&temp, wpath.c_str(),width , height);
	engine1->putimage_alpha(x, y, &temp, 255);
	FlushBatchDraw();
	pause(timeout);
	delete engine1;
}

void initGameCli(int count)
{
	system("title ?????VS???????");
	system("mode con cols=120 lines=30");
	system("cls");
	if (count == 1)
		directOutput("?! ?????????????? :P", 1);
	else if (count == 2)
		directOutput("???? hello, again? ", 1);
	else if (count == 5)
		directOutput("??? ????????? ", 1);
	else
		directOutput("??????~~", 1);
	pause(0);
}

// ??????
int main()
{
	int count = 1;
	int temp = 0;
BEGINING:
	Engine* engine = new Engine();
	vector<string> choices;
	int choice = 0;
	engine->initGame();
	setbkcolor(BLACK);
	// ???¡À??
	initGameCli(count++);
	putImg(0, 0, 600, 300, "./PictureResource/CG/StickmanSay.png", 0);
	streamOutput("????????, ???????????2048...", 50, 0);
	directOutput("(??????2048????????§Ø?)", -1);

	// ????
	streamOutput("WASD???, Q????????.", 10, 0);
	setbkcolor(WHITE);
	engine->runGame2048();
	engine->FadeOut(720, 480, "./PictureResource/black.png", 10, 0);
	setbkcolor(BLACK);
	clean();
	// ???????
	directOutput("??!", 1);
	for (int i = 0; i < 3; ++i) {
		putImg(0, 0, 720, 480, "./PictureResource/white.png", 0);
		putImg(0, 0, 720, 480, "./PictureResource/black.png", 0);
		Sleep(100);
	}
	setbkcolor(BLACK);
	clean();
	streamOutput("????????????!!! (?????????????)", 10, 0,WHITE);
	streamOutput("???..????...???......", 50, 2,WHITE);
	for (int i = 0; i < 3; ++i)
	{
		putImg(0, 0, 600, 300, "./PictureResource/CG/StickmanSay.png", 0);
		Sleep(80);
		putImg(0, 0, 600, 300, "./PictureResource/black.png", 0);
		putImg(30, 30, 600, 300, "./PictureResource/CG/StickmanSay.png", 0);
		Sleep(80);
		putImg(0, 0, 600, 300, "./PictureResource/black.png", 0);
		
	}
	putImg(0, 0, 600, 300, "./PictureResource/black.png", 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/StickmanSay.png", 0);//???????????????
	directOutput("???!!!", 1);
	streamOutput("???????????????????...(?????????)", 10, 0);
	streamOutput("????????, ??????????????????????????.", 10, 0);
	streamOutput("???????, ???????????????.", 10, 0);
	streamOutput("????????????????????????...!", 10, 0);
	directOutput("(???????????????????§Ø?)", -1);
	// ?????
	streamOutput("WASD???, Q????????, R??????.", 10, 0);
	engine->runGameSokoban();
	clean();
	streamOutput("???~~~~~~~~~~", 100, 2);
	streamOutput("???????????????????¦Ë?¨²?,", 10, 0);
	streamOutput("?????????????????????????...", 10, 0);
	temp = 0;
	// ???????
	do
	{
		putImg(0, 0, 600, 300, "./PictureResource/CG/StickmanChoice.png", 0);
		choice = choiceOutput("?????:", {"?????????", "?????????", "???????"});
		switch (choice)
		{
		case 1:
			if (temp)
			{
				streamOutput("??????.", 10, 0);
				break;
			}
			clean();
			putImg(0, 0, 600, 300, "./PictureResource/CG/key.png", 0);
			streamOutput("???????????????????, ????????????????.", 10, 0);
			streamOutput("??????????, ????????????...", 10, 0);
			temp = 1;
			break;

		case 2:
			clean();
			putImg(0, 0, 600, 300, "./PictureResource/CG/door.png", 0);
			streamOutput("???????????????????, ??????????????...", 10, 0);
			streamOutput("??????????????????.", 10, 0);
			break;

		default:
			break;
		}
		Sleep(2000);
		clean();
	} while (choice != 3);
	clean();
	putImg(0, 0, 600, 300, "./PictureResource/CG/mario.png", 0);
	// ???????
	streamOutput("?????????????????????..?", 10, 0);
	streamOutput("????????????????????.(??????)", 10, 0);
	streamOutput("??????????????????......", 10, 0);
	streamOutput("......", 60, 1);
	streamOutput("......", 60, 1);
	streamOutput("???~~~~~~~~~~", 100, 2);
	streamOutput("?????????§Û??.", 10, 0);
	clean();

	// ???????
	streamOutput("??????????????????...", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/castle.png", 0);
	streamOutput("??????????????. emmm?Ú…???????????????????????...", 10, 0);
	streamOutput("??????,?????????????????\"???????\"...", 10, 0);
	clean();
	putImg(0, 0, 600, 300, "./PictureResource/CG/lucky.png", 0);
	choice = choiceOutput("?????:", {"???????", "???????", "?????", "????????"});
	clean();
	switch (choice)
	{
	case 1:
		streamOutput("?????????,", 10, 0);
		for (int i = 0; i < 3; ++i) {
			putImg(0, 0, 720, 480, "./PictureResource/white.png", 0);
			putImg(0, 0, 720, 480, "./PictureResource/black.png", 0);
			Sleep(100);
		}
		streamOutput("??????????...", 100, 1);
		streamOutput("???? ??.", 200, -1);
		clean();
		delete engine;
		goto BEGINING;
	case 2:
		clean();
		streamOutput("??, ????????, ??????CT????.", 10, 0);
		streamOutput("???????, ????????????.", 10, 0);
		choice = choiceOutput("?????:", {"??????????????", "???????¦¶"});
		clean();
		switch (choice)
		{
		case 1:
			streamOutput("????????.", 100, 1);
			for (int i = 0; i < 3; ++i) {
				putImg(0, 0, 720, 480, "./PictureResource/white.png", 0);
				putImg(0, 0, 720, 480, "./PictureResource/black.png", 0);
				Sleep(100);
			}
			streamOutput("????????¡¤???????????????.", 60, 1);
			streamOutput("???? ??.", 200, -1);
			clean();
			delete engine;
			goto BEGINING;
		case 2:
			streamOutput("???????????????", 10, 0);
			putImg(0, 0, 720, 480, "./PictureResource/CG/tennal.png", 0);
			streamOutput("????...", 10, 0);
			streamOutput("?????????????????????...(?????????)", 10, 0);
			streamOutput("????, ?????????????...", 10, 0);
			clean();
			break;
		default:
			break;
		}
	case 3:
		putImg(0, 0, 600, 300, "./PictureResource/CG/lucky.png", 0);
		streamOutput("???????????.", 10, 0);
		streamOutput("????????????????, ?????????????????.", 10, 0);
		streamOutput("????????????ŽN.", 10, 0);
		streamOutput(".......", 100, 3);
		clean();
	case 4:
		putImg(0, 0, 600, 300, "./PictureResource/CG/lucky.png", 0);
		streamOutput("????????????????, ??????????...", 10, 0);
		streamOutput("??????????????????????????????????.", 10, 0);
		streamOutput("??????????????????----?????????.", 10, 0);
		streamOutput("??????, ?????????¡Â????????????.", 10, 0);
		streamOutput("????????????...", 10, 0);
		streamOutput("???????????, ?????, ?????¡Â???:", 60, 1);
		streamOutput("???????????????????????????.", 10, 0);
		clean();
		break;
	default:
		break;
	}

	// ?????
	streamOutput("???????????????????!", 10, 0);
	streamOutput("???????????????????????????...", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("?????????:", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"???????????????????!\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"??????????????????????Ïî?????????,\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"¦·??????????????,?????¨¢????????????!\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"?????????????????????????¦Ë...\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"????????????????????! \"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"???ýq???????????????????????????????????????????!\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"----?????????????????! \"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"¦·?§à???????????????, ??????????????????????----????????????!\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	streamOutput("\"???????!???????????!!????????????????!!!\"", 10, 0);
	putImg(0, 0, 600, 300, "./PictureResource/CG/God.png", 0);
	directOutput("\n(?????\"?????????\"????????§Ø?)\n", -1);
	clean();

	streamOutput("WASD????????????, Q????????, R??????.", 10, 0);
	engine->runGameTetris();
	clean();

	// ???????
	streamOutput("??????!!! ", 10, 0);
	streamOutput("????????, ???????, ????????...", 10, 0);
	streamOutput("??????????????, ?¦Ê??????????!(???????????????)", 10, 0);

	choice = choiceOutput("?????:", {"????????", "???????????", "????????"});
	switch (choice)
	{
	case 1:
		streamOutput("row~~~~~~bomb!", 60, 1);
		streamOutput("????????????????????, ??????????????...", 10, 0);
		streamOutput("???? ??.", 200, -1);
		clean();
		delete engine;
		goto BEGINING;
	case 2:
		clean();
		streamOutput("????????????. ?????????§Ú?????????????.", 10, 0);
		break;
	case 3:
		streamOutput("????, ????????ùz??????...", 10, 0);
		streamOutput("???§Ü????...", 10, 0);
		streamOutput("......", 100, 1);
		streamOutput("???§³??????????????????.", 100, 1);
		streamOutput("???? ??.", 200, 0);
		clean();
		delete engine;
		goto BEGINING;
	default:
		break;
	}
	temp = 0;
	do
	{
		choice = choiceOutput("?????:", {"??????", "??????", "?????????"});
		switch (choice)
		{
		case 1:
			streamOutput("????????????????:", 10, 0);
			streamOutput("??????????????!", 10, 0);
			streamOutput("????????????, ?¡¤?????????, ????????, ?????????!", 10, 0);
			streamOutput("??????!??----??????????????????.", 10, 0);
			streamOutput("????§³??!??", 10, 0);
			streamOutput("????????, ??????????§Ù???, ????????§Ö?????????Ïî.", 10, 0);
			streamOutput("????????, ???????›é??, ??????????????????.", 10, 0);
			streamOutput("????????...???, ??????????????, ???????????????.", 10, 0);
			streamOutput("?????????----??", 10, 0);
			streamOutput("??????????????????!", 10, 0);
			streamOutput("??----???????? ???????????????!??", 10, 0);
			streamOutput("(???§³??: ??????, ??????????????????,)", 10, 0);
			streamOutput("(????????99%???????????...)", 10, 0);
			streamOutput("(...???.)", 60, 1);
			break;
		case 2:
			temp++;
			if (temp == 1)
			{
				streamOutput("???????????????...", 10, 0);
				streamOutput("???????????????????.", 10, 0);
				streamOutput("?????????????????.", 10, 0);
				streamOutput("????????????§Ö??????????...", 10, 0);
			}
			else if (temp > 1 && temp < 6)
			{
				streamOutput("???????????.", 10, 0);
			}
			else if (temp == 6)
			{
				streamOutput("?????????...", 10, 0);
				streamOutput("???????????..?", 10, 0);
				streamOutput("......", 100, 1);
				streamOutput("......", 100, 1);
				streamOutput("???, ???????", 10, 0);
				srand(static_cast<unsigned int>(time(nullptr)));
				int seed = rand() % 5;
				if (seed == 0)
				{
					streamOutput("???, ??????????...", 10, 0);
					temp = 0;
					goto BOSS;
				}
				else
				{
					streamOutput("?????????.", 10, 0);
					streamOutput("??????????.", 10, 0);
				}
			}
			else
			{
				streamOutput("??????. ????.", 10, 0);
				streamOutput("???????????.", 10, 0);
			}
			break;
		case 3:
			streamOutput("?????????...", 10, 0);
			streamOutput("......", 60, 1);
			streamOutput("......", 60, 1);
			streamOutput("??????????...", 60, 1);
			break;
		default:
			break;
		}
		clearRect(300,0x00000);
	} while (choice != 1);
	clean();

	// ????????
	streamOutput("???????, ???????????????...", 10, 0);
	streamOutput("?????????, ???????????????????????????????.", 10, 0);
	streamOutput("???~~~~~~~~~~", 100, 2);
	streamOutput("????????, ???????????????.", 10, 0);
	streamOutput("????, ??????¨°???????????.", 10, 0);
	streamOutput("......", 60, 1);
	streamOutput("?????????.", 10, 0);
	streamOutput("????????????????????...", 10, 0);
	streamOutput("(??????????????,?????????????????????????.. ??????????????,?§Õ????)", 10, 0);
	directOutput("\n(??????????????????????§Ø?)\n", -1);
	clean();

	// ??????
	streamOutput("WASD???????????, Q????????, R??????.", 10, 0);
	engine->runGameSnake();
	clean();

	// ???????
	streamOutput("????????????, ???...", 10, 0);
	streamOutput("?????????????????????????!", 10, 0);
	streamOutput("????...??????????????????..?", 10, 0);
	streamOutput("?????????????! (?????????.JPG)", 10, 0);
	directOutput("\n(????¦Ï?????????????????§Ø?)\n", -1);

	// ?????
	streamOutput("WASD???????, Q????????, R??????.", 10, 0);
	engine->runGameSokoban(); // ???cv
	clean();

	// ???????
	streamOutput("???~~~~~~~~~~", 100, 2);
	streamOutput("?????§»?????, ????????????.", 10, 0);
	streamOutput("......", 60, 1);
	streamOutput("???????????????????.", 10, 0);
	do
	{
		choices = { "??????", "??????", "??????????", "????????¦¶", "????????" };
		choice = choiceOutput("?????:", choices);
		switch (choice)
		{
		case 1:
			streamOutput("??????????????????:", 10, 0);
			streamOutput("JuFireStudio", 10, 0);
			streamOutput("??...??????¦Á?????...", 10, 0);
			break;
		case 2:
			streamOutput("?????¦Å???, ??????????...(bushi)", 10, 0);
			break;
		case 3:
			streamOutput("???????????...", 10, 0);
			streamOutput("??????????????.??????????????????????...", 10, 0);
			streamOutput("......", 60, 1);
			streamOutput("????????...", 10, 0);
			streamOutput("????????????????, ???????????????????????...", 10, 0);
			streamOutput("???????, ??????????.", 10, 0);
			streamOutput("??????????. ??????????????, ????????????.", 10, 0);
			break;
		case 4:
			streamOutput("?????????. ??????Minecraft?????.", 10, 0);
			streamOutput("???????????????????, ???, ??...", 10, 0);
			streamOutput("????????????...", 10, 0);
			break;
		default:
			break;
		}
		clearRect(300,0x00000);
	} while (choice != 5);
	clean();

	// ???????
	streamOutput("??????????...", 10, 0);
	do
	{
		choices = { "?????????", "??????", "??????§Ö????", "?????????", "??????" };
		choice = choiceOutput("?????:", choices);
		switch (choice)
		{
		case 1:
			streamOutput("JuFireStudio...", 10, 0);
			streamOutput("(???????)", 10, 0);
			break;
		case 2:
			streamOutput("???????????????????¿B??.", 10, 0);
			streamOutput("????????????????????????????????.", 10, 0);
			break;
		case 3:
			streamOutput("???????§Ö????, ????????????????????.", 10, 0);
			streamOutput("???????§»????????, ????????.", 10, 0);
			break;
		case 4:
			streamOutput("???????.", 10, 0);
			streamOutput("?????????????????. ????????§Ö??????????.", 10, 0);
			break;
		default:
			break;
		}
		clean();
	} while (choice != 5);

	// BOSS ???
	streamOutput("?????????????????...", 10, 0);
BOSS:
	streamOutput("????????:", 10, 0);
	streamOutput("\"???????!???????????.\"", 10, 0);
	streamOutput("\"???????????????.\"", 10, 0);
	streamOutput("\"???????, ???????????????????????!\"", 10, 0);
	streamOutput("???????, ???????????????...", 10, 0);
	directOutput("\n(??????????????)\n", -1);

	streamOutput("WASD??????, Q????????, R??????.", 10, 0);
	engine->runGamePacman();
	clean();

	// ???????
	streamOutput("?????????????????????!", 10, 0);
	streamOutput("???????.", 10, 0);
	streamOutput("??????????????, ??????¦Ä????2048...", 10, 0);
	clean();

	// ?????
	streamOutput("(???????????, ??????????????????????2048??§à?, ???2048???????)", 10, -1);

	delete engine;
	return 0;
}